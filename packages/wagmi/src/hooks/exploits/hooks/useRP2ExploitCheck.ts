'use client'

import { useQuery } from '@tanstack/react-query'
import { RouteProcessor2ChainId } from 'sushi/config'
import { Token } from 'sushi/currency'
import { Address } from 'wagmi'
import { fetchToken } from 'wagmi/actions'
import { z } from 'zod'

import rp2Approvals from '../data/rp2-approvals.json'

const rp2ApprovalsItemSchema = z.object({
  address: z.string().transform((el) => el as Address),
  transactionHash: z.string(),
  spender: z.string().transform((el) => el as Address),
  owner: z.string().transform((el) => el as Address),
  value: z.number(),
})

const rp2ApprovalsSchema = z.record(
  z.coerce.number().transform((el) => el as RouteProcessor2ChainId),
  z.array(rp2ApprovalsItemSchema),
)

interface UseRP2ExploitCheck {
  account: Address | undefined
}

export const useRP2ExploitCheck = ({ account }: UseRP2ExploitCheck) => {
  return useQuery({
    queryKey: ['useRP2ExploitCheck', { account }],
    enabled: Boolean(account),
    queryFn: async () => {
      if (!account) return []

      const approvals = rp2ApprovalsSchema.parse(rp2Approvals)
      const items = Object.entries(approvals)
      const tokens: Token[] = []

      for (let i = 0; i < items.length; i++) {
        const [key, value] = items[i]
        const chainId = +key as RouteProcessor2ChainId

        for (let j = 0; j < value.length; j++) {
          const item = value[j]
          if (item.owner.toLowerCase() === account.toLowerCase()) {
            const resp = await fetchToken({ address: item.address, chainId })
            const { decimals, address: tokenAddress, symbol, name } = resp
            const token = new Token({
              chainId,
              address: tokenAddress,
              symbol,
              name,
              decimals,
            })

            if (!tokens.map((el) => el.id).includes(token.id)) {
              tokens.push(token)
            }
          }
        }
      }

      return tokens
    },
    refetchOnWindowFocus: false,
    refetchOnReconnect: false,
    refetchIntervalInBackground: false,
    refetchOnMount: false,
    refetchInterval: 10000 * 60 * 60,
  })
}
